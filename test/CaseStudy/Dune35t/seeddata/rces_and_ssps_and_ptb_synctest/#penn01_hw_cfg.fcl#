 daq: {
  # The SSPs have 262144. Not sure if it is relevant
  # The RCEs have 1048576. Not sure if it is relevant
  max_fragment_size_words: 1048576 
  
  fragment_receiver: {
    mpi_buffer_count: 16
    mpi_sync_interval: 24000
    
    # These two variables will be calculated by DAQInterface...
    first_event_builder_rank: -1
    event_builder_count: -1
    
    generator: PennReceiver
    fragment_type: PTB
    fragment_id: 0
    board_id: 0
    
    # Don't know what this is for. Seems to be some sort of wait 
    # time between sending stop command to PTB and issuing the stop
    # transition to the board reader    
    #sleep_on_stop_us: 1000000
    sleep_on_stop_us: 500000
    #sleep_on_stop_us: 0
    
    # The real configuration options for the PTB
    penn_client_host_addr     : '192.168.100.205' # the IP of the PTB
    penn_client_host_port     : 8991                # client port
    penn_client_timeout_usecs : 5E5                 # connection timeout. This is a board_reader option
           
    #**Important note**                                                                           
    #NOvA clock is multiplied up so that the internal logic runs faster at 64 MHz 
    # but NOvA ticks used for timestamp generation 
    # (and thus affecting physical millislice length) are at 64 MHz.                      

    receiver_tick_period_usecs    : 1E4       # board reader waiting timeout 
    millislice_size               : 320000    # The size of the millislice in 
    				    	      # **NOvA register** units (64MHz)
                                              # Default : 320000 (5ms)
                                              # IMPORTANT: This value has to be kept 
					      # in sync with the other board readers
                                              # or the DAq will refuse to init
    millislice_overlap_size       : 0         # Millislice overlap. 
    				    	      # Not sure what is a reasonable value here
                                              # A good value would probably be 10%
                                              # 32000 == 5 microsecs 
    receiver_debug_level          : 0         # higher number = print more info 
    				    	      # (6 is current highest level with lots of bitset dumps)

    reporting_interval_fragments  : 10        # Interval between fragments that a report is printed
    reporting_interval_time       : 0         # Time interval between reports (in seconds)
    
    raw_buffer_size               : 4000000   # Using the same value as the RCEs. 
    				    	      # Size of the artdaq fragment requested 
					      # from downstream.
    raw_buffer_precommit          : 10        # Number of precommitted buffers
    use_fragments_as_raw_buffer   : true      # false not currently implemented/tested
    				    	      # Eventually we might want to have it, but
					      # currently it is not strictly necessary

####################################################################
#
# PTB configuration options. These are then translated into a 
# XML file that is parsed in the PTB
#
#
# NOTES: 
#     - Logic. All logic follows the rule: (00: AND, 01: OR, 2: XOR, 3: UNIQUE) 
#
#
####################################################################

   dry_run_mode : false		# Dry run mode. All configurations are uploaded but so that
   		  		# configured calibrations and trigger pulses are produced
				# but no data is neither collected not transmitted to the 
				# board reader. useful to generate random triggers.
   		  		

   penn_data_buffer : {
      daq_host            : "192.168.100.101"  # Where the board reader is running
      daq_port            : 8992	       # Board reader listen port.
      daq_rollover        : 1500               # Number of packets before the slice
      			    		       # is broken into a fragment.
					       # Don't touch unless you know what you're 
					       # doing. Currently not being used
      daq_microslice_size : 64000              # Time based rollover (main). 
                                               # Can be any value that fits a 27 bit word.
                                               # MUST BE SMALLER THAN MILLISLICE SIZE
    }
  
    channel_mask : {
       BSU : 0x3FFFFFFFFFFFF   # All 50 channels are ON
       TSU : 0xFFFFFFFFFFFF    # All 48 channels are ON 

#      BSU : 0x0	       # All 50 channels are OFF
#      TSU : 0x0    	       # All 48 channels are OFF
    }
  
   hardware : {
     pulse_width : 10     # Width of all output pulses in counts of NOvA clock
                          # Range 1-63 (32.250-2031.75) ns
   }
   
    muon_triggers : {
      trig_window : 3     # Number of clock ticks that the input signal
                          #  is stretched to account for time offsets between panels
                          # Range: [0-15] --> (0 - 483.75) ns
      trig_lockdown : 11  # Number of clock ticks that the input signal is
                          #  locked low after being high. Accounts for reflections.
                          # Range: [0-63] --> (0 -  2031.75) ns
      num_triggers : 4    # Number of different trigger masks
  
      trigger_0 : {
        id      : "A"      # Just something for debugging purposes
        id_mask : "1000"   # Not used at the moment. Same ID as the IP in the PL
        logic   : 0x0        # Logic to be applied between groups (0: AND) 
        prescale: 0        # Number of ignored triggers after a successful trigger
                           # Range [0-255] 
        group1 : {         
          logic : 3        # UNIQUE
          BSU   : 0xFFFF   # BSU mask (RM 1-16)
          TSU   : 0x0      # TSU mask
        }
        group2 : {
          logic : 3               # UNIQUE
          BSU   : 0x7F7E000000    # BSU mask (CL 1-13)
          TSU   : 0x0             # TSU mask
        }                           
      }
  
      trigger_1 : {
        id      : "B"     
        id_mask : "0100"
        logic   : 0x0 
        prescale: 0 
        group1 : {
          logic : 1 
          BSU   : 0x0 
          TSU   : 0x3F000000
        }
        group2 : {
          logic : 1
          BSU   : 0x0 
          TSU   : 0xFC0000000
        }
      }
  
      trigger_2 : {
        id      : "C"  
        id_mask : "0010"
        logic   : 0 
        prescale: 0 
        group1 : {
          logic : 1                      # OR
          BSU   : 0x0                    # BSU mask
          TSU   : 0xFC0000000000         # TSU mask (SU 1-6)
        }
        group2 : {
          logic : 1                       # OR
          BSU   : 0x0                     # BSU mask
          TSU   : 0x3F000000000           # TSU mask (NL 1-6)
        }                            
      }
  
      trigger_3 : {
        id      : "D"      # Just something for debugging purposes
        id_mask : "0001"   # Not used at the moment. Same ID as the IP in the PL
        logic   : 0        # Logic between groups (0: AND, 1: OR, 2: XOR, 3: UNIQUE) 
        prescale: 0        # Number of triggers ignored after a successful trigger
        group1 : {
          logic : 1        # OR
          BSU   : 0x0      # BSU mask
          TSU   : 0x7FE00  # TSU mask (EL 1-10)
        }
        group2 : {         
          logic : 1        # OR
          BSU   : 0x0      # BSU mask
          TSU   : 0x1FF    # TSU mask (WU 1-10)
        }                           
      }
    }
  
    external_triggers : {
      mask          : 0xF      # Mask the external triggers (receiving). 
                                # There are 4 independent + 8 ored (total of 5 bits) 
      echo_triggers : false     # Should a trigger be sent back to the other systems?
                                # "true" not implemented yet
    }   
  
    calibrations : {
        C1 : {
           id           : "C1"     # Just an ID to keep in mind
           id_mask      : "1000"   # The ID that is effectively going into the PL
           enabled      : true     # enable/disable
           period       : 320000   # Number of clock ticks between calibration pulses
                                   # Range : [0-2147483647] --> (0 - ~1 min)
				   # 320000 => 10 Hz
        }
        C2 : {
           id           : "C2"   
           id_mask      : "0100"
           enabled      : false
           period       : 10     
        }
        C3 : {
           id           : "C3"    # Just an ID to keep in mind
           id_mask      : "0010"
           enabled      : false
           period       : 10     
        }
        C4 : {
           id           : "C4"   
           id_mask      : "0001"
           enabled      : false
           period       : 10     
        }
  }


        #
        # Emulator options. Same as before. Seems a bit cryptic
        #
                
        penn_data_num_millislices   : 1         # 0=Run until stopped
        penn_data_num_microslices   : 1000
        penn_data_frag_rate         : 1000      # Hz
        
        # Same for these -- what to these mean?
        penn_data_payload_mode                  : 2         # counter&trigger payload contents 0=all off, 1=all on, 2=alternating on/off, 3=random
        penn_data_trigger_mode      : 2         # 0=no trigger words sent. 1=trigger word sent every tick. 2=trigger word sent randomly
  
        penn_data_fragment_microslice_at_ticks : 0         #after this many ticks the uslice will be fragmented (<=0 means fragment automatically based on size)
        
        penn_data_repeat_microslices           : false     #for rate testing
        penn_data_debug_partial_recv           : false     #slows emulator down to send 1 byte at a time, every 0.1 seconds. For testing how the boardreader handles async_receive that grabs less than requested bytes
        

}
}
